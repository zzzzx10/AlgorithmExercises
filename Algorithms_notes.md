算法图解+剑指offer的笔记

#### TODO List: 

- [x] 算法图解 chap
  - [x] 1 2 3 4 5
  - [x] 6  7
  - [x] 8
  - [x] 9 10 11
- [ ] 剑指offer chap
  - [ ] 1 2
  - [ ] 3 4



# 大O表示法

说的是最糟的情况，考虑到列表很长的情况，常量无关紧要

从快到慢：

- O(log n)，也叫对数时间，包括二分查找。
- O(n)，也叫线性时间，包括简单查找。
- O(n * log n)，包括快速排序
- O(n^2)，选择排序
- O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案
  ——一种非常慢的算法。



# 数据结构

### 数组和链表

|      | 数组 | 链表 |
| :--: | :--: | :--: |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

数组支持随机访问，链表只能顺序访问。链表擅长插入和删除

Facebook存储用户信息时使用的是一种混合数据：链表数组。数组包含26个元素，每个元素都指向一个链表

数组中也是一种哈希表，下标是key，数组中的数字为value

> 字符串
>
> 字符串可以看做字符数组 “0123456789”实际末尾还有'\0'字符，因此实际长度为11字节

### 栈

LIFO 栈顶元素 压入（插入）和弹出（删除并读取）

### 队列

FIFO

### 哈希表

也被称为散列表、散列映射、映射、字典和关联数组

散列表由键和值组成，将键映射到值

哈希函数：将同样的输入映射到相同的索引，将不同的输入映射到不同的索引，只返回有效的索引

适用于：模拟映射关系；防止重复；缓存/记住数据，以免服务器再处理生成

|      | 平均 | 最糟 |
| :--: | :--: | :--: |
| 查找 | O(1) | O(n) |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

避免冲突，需要有：较低的填装因子；良好的散列函数。

填装因子：包含的元素数 / 总位置数



### 树

在二叉查找树中查找节点时，平均运行时间为O(log n)，但在最糟的情况下所需时间为O(n)

|      | 数组 |  二叉树  |
| :--: | :--: | :------: |
| 读取 | O(1) | O(log n) |
| 插入 | O(n) | O(log n) |
| 删除 | O(n) | O(log n) |

- B树
- 红黑树
- 堆
- 伸展树



# 算法

## 排序

[二分查找](./basic/binary_search.py)   O(log n)

[选择排序](./basic/selection_sort.py)：遍历列表，找出最值添加到新列表，循环  O(n^2)

[快速排序](./basic/quick_sort.py)  最糟糕O(n^2) 平均O(n log n)

合并排序 O( n log n)



## 递归

- 基线条件（base case，跳出递归的条件）+递归条件（recursive case）
- 所有函数调用都进入调用栈
- 调用栈可能很长，这将占用大量的内存，程序可能因栈溢出而终止 => 重新编写代码，转而使用循环。



## 图的路径

### 最短路径

广度优先搜索 breadth first search BFS

BFS:

创建邻居节点的队列，弹出一个节点，检查：如果是，结束；如果否，将此节点的邻居都加入队列

### 最快路径

针对非负加权图 + 有向**无环**图directed acyclic graph，DAG

##### 狄克斯特拉算法 Dijkstra's algorithm

1. 找出当前可到达的“最便宜”的节点，即可在最短时间内到达的节点。不知道的设为无穷大
2. 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。
3. 重复这个过程，直到对图中的每个节点都这样做了。
4. 计算最终路径。



负边权：贝尔曼-福德算法（Bellman-Ford algorithm）



## 贪婪算法

每步都选择局部最优解，最终得到的就是全局最优解

快速排序、广度优先搜索、狄克斯特拉算法， 都是贪婪算法

贪婪算法易于实现、运行速度快，是NP问题的近似解法

### NP完全问题

- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
- 涉及“所有组合”的问题通常是NP完全问题。
- 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。
- 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

e.g.  有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径； 在一堆人中找出最大的朋友圈（即其中任何两个人都相识）；地图上色，相邻颜色不同



## 动态规划

给定约束下，优化某种指标。先解决子问题（离散的），再逐步解决大问题

```
cell[i][j] = 1.上一行单元格的值cell[i-1][j]
			 2.当前价值+剩余空间价值cell[i-1][j-当前商品重量]
			 两者中的最大值
```

各行排列顺序无关紧要

 动态规划针对的是物品的整部分，要么有，要么没有；如果计算部分物品，用贪婪算法

应用：最长公共子序列、最长公共子串



## K最近邻算法

用处：分类，回归

*每个人评分标准不一样时，使用normalization归一化；余弦相似度

*给意见领袖更大的权重值

一个不错的经验规则是：如果有N位用户，应考虑sqrt(N)个邻居。



##  MapReduce

映射（map）函数和归并（reduce）函数

映射函数很简单，它接受一个数组，并对其中的每个元素执行同样的处理

```python
>>> arr1 = [1, 2, 3, 4, 5]
>>> arr2 = map(lambda x: 2 * x, arr1)
[2, 4, 6, 8, 10]
```

```python
>>> arr1 = [1, 2, 3, 4, 5]
>>> reduce(lambda x,y: x+y, arr1)
15
```



## More

布隆过滤器

HyperLogLog

SHA算法

Diffie-Hellman密钥交换

线性规划 Simplex算法



# 语言

## C++

sizeof(a) 求数组的大小，是a占用的字节数

在32位系统上，任意指针求sizeof，结果都是4；64位系统是8

GetSize(b)中b会退化为指针



两个字符串用==判断，实际是在判断是否指向同一内存地址

String修改后，新结果要用返回值得到。StringBuilder可以直接修改字符串内容