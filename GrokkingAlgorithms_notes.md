# TODO List: Chap

- [x] 1
- [x] 2
- [x] 3
- [x] 4
- [x] 5
- [x] 6
- [x] 7
- [x] 8
- [ ] 9
- [ ] 10
- [ ] 11



# 大O表示法

说的是最糟的情况，考虑到列表很长的情况，常量无关紧要

从快到慢：

- O(log n)，也叫对数时间，包括二分查找。
- O(n)，也叫线性时间，包括简单查找。
- O(n * log n)，包括快速排序
- O(n^2)，选择排序
- O(n!)，这样的算法包括接下来将介绍的旅行商问题的解决方案
  ——一种非常慢的算法。



# 数据结构

### 数组和链表

|      | 数组 | 链表 |
| :--: | :--: | :--: |
| 读取 | O(1) | O(n) |
| 插入 | O(n) | O(1) |
| 删除 | O(n) | O(1) |

数组支持随机访问，链表只能顺序访问。链表擅长插入和删除

Facebook存储用户信息时使用的是一种混合数据：链表数组。数组包含26个元素，每个元素都指向一个链表

### 栈

LIFO 栈顶元素 压入（插入）和弹出（删除并读取）

### 队列

FIFO

### 哈希表

也被称为散列表、散列映射、映射、字典和关联数组

散列表由键和值组成，将键映射到值

哈希函数：将同样的输入映射到相同的索引，将不同的输入映射到不同的索引，只返回有效的索引

适用于：模拟映射关系；防止重复；缓存/记住数据，以免服务器再处理生成

|      | 平均 | 最糟 |
| :--: | :--: | :--: |
| 查找 | O(1) | O(n) |
| 插入 | O(1) | O(n) |
| 删除 | O(1) | O(n) |

避免冲突，需要有：较低的填装因子；良好的散列函数。

填装因子：包含的元素数 / 总位置数



### 图



### 树





# 算法

[二分查找](./basic/binary_search.py)   O(log n)

[选择排序](./basic/selection_sort.py)：遍历列表，找出最值添加到新列表，循环  O(n^2)

[快速排序](./basic/quick_sort.py)  最糟糕O(n^2) 平均O(n log n)

合并排序 O( n log n)



## 递归

- 基线条件（base case，跳出递归的条件）+递归条件（recursive case）
- 所有函数调用都进入调用栈
- 调用栈可能很长，这将占用大量的内存，程序可能因栈溢出而终止 => 重新编写代码，转而使用循环。



## 图的路径

### 最短路径

广度优先搜索 breadth first search BFS

BFS:

创建邻居节点的队列，弹出一个节点，检查：如果是，结束；如果否，将此节点的邻居都加入队列

### 最快路径

针对非负加权图 + 有向**无环**图directed acyclic graph，DAG

##### 狄克斯特拉算法 Dijkstra's algorithm

1. 找出当前可到达的“最便宜”的节点，即可在最短时间内到达的节点。不知道的设为无穷大
2. 对于该节点的邻居，检查是否有前往它们的更短路径，如果有，就更新其开销。
3. 重复这个过程，直到对图中的每个节点都这样做了。
4. 计算最终路径。



负边权：贝尔曼-福德算法（Bellman-Ford algorithm）



## 贪婪算法

每步都选择局部最优解，最终得到的就是全局最优解

快速排序、广度优先搜索、狄克斯特拉算法， 都是贪婪算法

贪婪算法易于实现、运行速度快，是NP问题的近似解法

### NP完全问题

- 元素较少时算法的运行速度非常快，但随着元素数量的增加，速度会变得非常慢。
- 涉及“所有组合”的问题通常是NP完全问题。
- 不能将问题分成小问题，必须考虑各种可能的情况。这可能是NP完全问题。
- 如果问题涉及序列（如旅行商问题中的城市序列）且难以解决，它可能就是NP完全问题。
- 如果问题涉及集合（如广播台集合）且难以解决，它可能就是NP完全问题。
- 如果问题可转换为集合覆盖问题或旅行商问题，那它肯定是NP完全问题。

e.g.  有个邮递员负责给20个家庭送信，需要找出经过这20个家庭的最短路径； 在一堆人中找出最大的朋友圈（即其中任何两个人都相识）；地图上色，相邻颜色不同



## 动态规划

